<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8" />
    <title>Misuzu Lyrics Helper</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      html,
      body {
        background: transparent;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
      }
      main {
        width: 100vw;
        height: 100vh;
        background: transparent;
        pointer-events: auto;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #lyrics-canvas {
        width: 100vw;
        height: 100vh;
        display: block;
        background: transparent;
      }
    </style>
  </head>
  <body>
    <main data-tauri-drag-region>
      <canvas id="lyrics-canvas"></canvas>
    </main>
    <script type="module">
      const canvas = document.getElementById('lyrics-canvas');
      const ctx = canvas?.getContext('2d');
      const DEFAULT_LINE = '歌词加载中';
      const FONT_STACK = "'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Segoe UI', sans-serif";
      let currentLine = DEFAULT_LINE;
      let lastPayload = null;

      const sanitizeText = (value) =>
        typeof value === 'string' ? value.trim() : '';

      const shouldShowTranslation = (payload) => {
        if (payload && typeof payload.show_translation === 'boolean') {
          return payload.show_translation;
        }
        return true;
      };

      const normalizeSegments = (segments) => {
        if (!Array.isArray(segments)) {
          return [];
        }
        return segments
          .map((segment) => ({
            original: sanitizeText(segment?.original),
            annotation: sanitizeText(segment?.annotation),
          }))
          .filter((segment) => segment.original.length > 0);
      };

      if (!canvas || !ctx) {
        const fallback = document.createElement('div');
        fallback.textContent = DEFAULT_LINE;
        fallback.style.cssText = `
          font-size: 26px;
          font-weight: 700;
          color: #ffffff;
          text-align: center;
          width: 100%;
          pointer-events: auto;
          text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        `;
        document.body.innerHTML = '';
        document.body.appendChild(fallback);
        console.error('无法初始化 Canvas 渲染环境');
      } else {
        const resizeCanvas = () => {
          const dpr = window.devicePixelRatio || 1;
          const width = window.innerWidth;
          const height = window.innerHeight;

          canvas.style.width = `${width}px`;
          canvas.style.height = `${height}px`;
          canvas.width = Math.max(1, Math.floor(width * dpr));
          canvas.height = Math.max(1, Math.floor(height * dpr));

          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.scale(dpr, dpr);

          return { width, height };
        };

        const drawSimpleLine = (text = '—', translation = null) => {
          const { width, height } = resizeCanvas();
          ctx.clearRect(0, 0, width, height);

          const content = text && text.length ? text : '—';
          const maxWidth = width * 0.82;
          let fontSize = Math.min(width, height) * 0.14;
          fontSize = Math.max(fontSize, 20);

          const setBaseFont = () => {
            ctx.font = `900 ${fontSize}px ${FONT_STACK}`;
          };

          setBaseFont();
          while (ctx.measureText(content).width > maxWidth && fontSize > 28) {
            fontSize -= 2;
            setBaseFont();
          }

          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';

          ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
          ctx.shadowBlur = fontSize * 0.16;

          ctx.lineWidth = Math.max(fontSize * 0.08, 2.5);
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.95)';
          ctx.strokeText(content, width / 2, height / 2);

          ctx.shadowBlur = fontSize * 0.05;
          ctx.fillStyle = '#ffffff';
          ctx.fillText(content, width / 2, height / 2);

          if (translation && translation.length) {
            let translationSize = Math.max(fontSize * 0.48, 16);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillStyle = 'rgba(236, 240, 255, 0.92)';

            const translationFont = () =>
              `600 ${translationSize}px ${FONT_STACK}`;

            ctx.font = translationFont();
            while (
              ctx.measureText(translation).width > width * 0.78 &&
              translationSize > 14
            ) {
              translationSize -= 1;
              ctx.font = translationFont();
            }

            const translationY = height / 2 + fontSize * 0.78;
            ctx.shadowBlur = translationSize * 0.06;
            ctx.lineWidth = Math.max(translationSize * 0.06, 1.8);
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.strokeText(translation, width / 2, translationY);
            ctx.shadowBlur = translationSize * 0.03;
            ctx.fillText(translation, width / 2, translationY);
          }
        };

        const drawSegments = (segments, translation = null) => {
          const normalizedSegments = normalizeSegments(segments);
          if (!normalizedSegments.length) {
            drawSimpleLine(currentLine, translation);
            return;
          }

          const { width, height } = resizeCanvas();
          ctx.clearRect(0, 0, width, height);

          const maxWidth = width * 0.82;
          let baseFontSize = Math.min(width, height) * 0.14;
          baseFontSize = Math.max(baseFontSize, 20);
          let annotationFontSize = Math.max(baseFontSize * 0.4, 12);

          const baseFont = () => `900 ${baseFontSize}px ${FONT_STACK}`;
          const annotationFont = () => `600 ${annotationFontSize}px ${FONT_STACK}`;

          ctx.font = baseFont();
          const measureTotalWidth = () =>
            normalizedSegments.reduce(
              (sum, segment) => sum + ctx.measureText(segment.original).width,
              0,
            );

          let totalWidth = measureTotalWidth();
          if (totalWidth > maxWidth) {
            const scale = maxWidth / totalWidth;
            baseFontSize = Math.max(18, Math.floor(baseFontSize * scale));
            annotationFontSize = Math.max(baseFontSize * 0.4, 12);
            ctx.font = baseFont();
            totalWidth = measureTotalWidth();
          }

          const baseY = height / 2;
          const annotationOffset = baseFontSize * 0.65;
          const startX = (width - totalWidth) / 2;
          let x = startX;

          ctx.textBaseline = 'middle';
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';

          normalizedSegments.forEach((segment) => {
            const text = segment.original;
            if (!text.length) {
              return;
            }

            ctx.font = baseFont();
            const segmentWidth = ctx.measureText(text).width;
            const centerX = x + segmentWidth / 2;

            ctx.textAlign = 'left';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
            ctx.shadowBlur = baseFontSize * 0.16;
            ctx.lineWidth = Math.max(baseFontSize * 0.08, 2.5);
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.95)';
            ctx.strokeText(text, x, baseY);

            ctx.shadowBlur = baseFontSize * 0.05;
            ctx.fillStyle = '#ffffff';
            ctx.fillText(text, x, baseY);

            const annotation = segment.annotation;
            if (annotation.length) {
              ctx.textAlign = 'center';
              ctx.textBaseline = 'bottom';
              ctx.font = annotationFont();
              ctx.lineWidth = Math.max(annotationFontSize * 0.06, 1.5);
              ctx.shadowBlur = annotationFontSize * 0.12;
              ctx.strokeStyle = 'rgba(0, 0, 0, 0.85)';
              ctx.strokeText(annotation, centerX, baseY - annotationOffset);
              ctx.shadowBlur = annotationFontSize * 0.04;
              ctx.fillStyle = 'rgba(240, 244, 255, 0.92)';
              ctx.fillText(annotation, centerX, baseY - annotationOffset);
            }

            x += segmentWidth;
          });

          if (translation && translation.length) {
            let translationSize = Math.max(baseFontSize * 0.5, 16);
            const translationFont = () =>
              `600 ${translationSize}px ${FONT_STACK}`;
            ctx.font = translationFont();
            while (
              ctx.measureText(translation).width > width * 0.78 &&
              translationSize > 14
            ) {
              translationSize -= 1;
              ctx.font = translationFont();
            }

            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.shadowBlur = translationSize * 0.06;
            ctx.lineWidth = Math.max(translationSize * 0.06, 1.8);
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
            const translationY = baseY + baseFontSize * 0.78;
            ctx.strokeText(translation, width / 2, translationY);
            ctx.shadowBlur = translationSize * 0.03;
            ctx.fillStyle = 'rgba(236, 240, 255, 0.92)';
            ctx.fillText(translation, width / 2, translationY);
          }
        };

        const resolveLine = (payload) => {
          const text = sanitizeText(payload?.active_line);
          return text.length ? text : DEFAULT_LINE;
        };

        const render = (payload) => {
          if (payload) {
            lastPayload = payload;
          }

          const targetPayload = payload ?? lastPayload;
          if (!targetPayload) {
            drawSimpleLine(DEFAULT_LINE);
            return;
          }

          const text = resolveLine(targetPayload);
          currentLine = text;
          document.title = text;

          const segments = normalizeSegments(targetPayload.active_segments);
          const showTranslation = shouldShowTranslation(targetPayload);
          const translation = showTranslation
              ? sanitizeText(targetPayload.active_translation)
              : '';
          const displayTranslation = translation.length ? translation : null;

          if (segments.length) {
            drawSegments(segments, displayTranslation);
          } else {
            drawSimpleLine(text, displayTranslation);
          }
        };

        const registerExitShortcuts = (tauriCore) => {
          const handler = (event) => {
            const key = event.key?.toLowerCase();
            const comboPressed = event.metaKey || event.ctrlKey;
            const exitViaQ = comboPressed && key === 'q';
            const exitViaEsc = comboPressed && key === 'escape';

            if (exitViaQ || exitViaEsc) {
              event.preventDefault();
              tauriCore.invoke('exit_app');
            }
          };

          window.addEventListener('keydown', handler);
        };

        async function init() {
          const tauri = window.__TAURI__;
          console.log('Tauri API 入口:', tauri);
          if (!tauri || !tauri.core || !tauri.event) {
            console.error('无法找到 Tauri API');
            drawSimpleLine(DEFAULT_LINE);
            return;
          }

          const { invoke } = tauri.core;
          const { listen } = tauri.event;

          drawSimpleLine(currentLine);

          try {
            const payload = await invoke('get_lyrics_state');
            console.log('初始歌词状态:', payload);
            render(payload);
          } catch (error) {
            console.error('获取初始歌词状态失败:', error);
            drawSimpleLine(DEFAULT_LINE);
          }

          try {
            await listen('lyrics:update', ({ payload }) => {
              console.log('收到歌词更新事件:', payload);
              render(payload);
            });
          } catch (error) {
            console.error('监听歌词更新失败:', error);
          }

          registerExitShortcuts(tauri.core);
        }

        window.addEventListener('resize', () => {
          if (lastPayload) {
            render(lastPayload);
          } else {
            drawSimpleLine(currentLine);
          }
        });

        init();
      }
    </script>
  </body>
</html>
